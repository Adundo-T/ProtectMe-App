import { createContext, useContext, useMemo, useState, useEffect, ReactNode } from 'react';
import { ApiService } from '@/services/api';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as LocalAuthentication from 'expo-local-authentication';
import { Alert, Linking } from 'react-native';
import {
  deleteReport as deleteReportFromDb,
  getPendingAlerts,
  getReports,
  getReportById,
  getResources,
  initializeDatabase,
  logPendingAlert,
  saveReport,
  updateReportStatus,
} from '@/services/database';
import type { AppState, ReportStatus, Report } from '@/types';

type AppContextValue = AppState & {
  actions: {
    createReport: (payload: { title: string; description: string; isAnonymous: boolean }) => Promise<void>;
    saveDraft: (payload: { id?: number; title: string; description: string; isAnonymous: boolean }) => Promise<void>;
    deleteReport: (id: number) => Promise<void>;
    markSynced: (id: number) => Promise<void>;
    triggerSOS: () => Promise<void>;
    syncNow: () => Promise<void>;
    completeOnboarding: () => Promise<void>;
    togglePinLock: () => Promise<void>;
    toggleBiometric: () => Promise<void>;
    loadReportForEdit: (id: number) => Promise<Report | undefined>;
    signIn: () => Promise<void>;
  };
};

const STORAGE_KEYS = {
  onboarding: '@protectme/onboarding-complete',
  pinEnabled: '@protectme/pin-enabled',
  biometricEnabled: '@protectme/biometric-enabled',
  authenticated: '@protectme/authenticated',
};

const SOS_NUMBER = '112';

const initialState: AppState = {
  reports: [],
  resources: [],
  pendingAlerts: [],
  syncState: 'idle',
  hasCompletedOnboarding: false,
  pinEnabled: false,
  biometricEnabled: false,
  loading: true,
  isAuthenticated: false,
};

const AppContext = createContext<AppContextValue | undefined>(undefined);

export function AppProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<AppState>(initialState);

  useEffect(() => {
    (async () => {
      await initializeDatabase();
      const [reports, resources, pendingAlerts] = await Promise.all([getReports(), getResources(), getPendingAlerts()]);
      const [[, onboardingValue], [, pinValue], [, biometricValue], [, authenticatedValue]] = await AsyncStorage.multiGet([
        STORAGE_KEYS.onboarding,
        STORAGE_KEYS.pinEnabled,
        STORAGE_KEYS.biometricEnabled,
        STORAGE_KEYS.authenticated,
      ]);

      setState((prev) => ({
        ...prev,
        reports,
        resources,
        pendingAlerts,
        hasCompletedOnboarding: onboardingValue === 'true',
        pinEnabled: pinValue === 'true',
        biometricEnabled: biometricValue === 'true',
        isAuthenticated: authenticatedValue === 'true',
        loading: false,
      }));
    })();
  }, []);

  const refreshReports = async () => {
    const reports = await getReports();
    setState((prev) => ({ ...prev, reports }));
  };

  const refreshAlerts = async () => {
    const pendingAlerts = await getPendingAlerts();
    setState((prev) => ({ ...prev, pendingAlerts }));
  };

  const createOrUpdateReport = async (
    payload: { id?: number; title: string; description: string; isAnonymous: boolean },
    status: ReportStatus,
  ) => {
    await saveReport({
      id: payload.id,
      title: payload.title,
      description: payload.description,
      status,
      isAnonymous: payload.isAnonymous,
    });
    await refreshReports();
  };

  const actions: AppContextValue['actions'] = {
    createReport: async ({ title, description, isAnonymous }) => {
      await createOrUpdateReport({ title, description, isAnonymous }, 'pending');
    },
    saveDraft: async ({ id, title, description, isAnonymous }) => {
      await createOrUpdateReport({ id, title, description, isAnonymous }, 'draft');
    },
    deleteReport: async (id: number) => {
      await deleteReportFromDb(id);
      await refreshReports();
    },
    markSynced: async (id: number) => {
      await updateReportStatus(id, 'synced');
      await refreshReports();
    },
    triggerSOS: async () => {
      await logPendingAlert(SOS_NUMBER);
      await refreshAlerts();
      const supported = await Linking.canOpenURL(`tel:${SOS_NUMBER}`);
      if (supported) {
        await Linking.openURL(`tel:${SOS_NUMBER}`);
      } else {
        Alert.alert('Unable to place call', `Please dial ${SOS_NUMBER} manually.`);
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    syncNow: async () => {
      if (state.syncState === 'syncing') return;
      setState((prev) => ({ ...prev, syncState: 'syncing' }));

      try {
        // Check if backend is available
        const backendAvailable = await ApiService.isBackendAvailable();
        if (!backendAvailable) {
          console.log('No backend connection available, staying offline');
          setState((prev) => ({ ...prev, syncState: 'idle' }));
          return;
        }

        // Get pending reports and alerts
        const pendingReports = state.reports.filter((report) => report.status === 'pending');
        const pendingAlerts = state.pendingAlerts.filter((alert) => alert.status === 'pending');

        // Sync reports
        if (pendingReports.length > 0) {
          const reportSyncData = pendingReports.map((report) => ({
            id: report.id,
            title: report.title,
            description: report.description,
            isAnonymous: report.isAnonymous,
            createdAt: report.createdAt,
            updatedAt: report.updatedAt,
          }));

          const reportResult = await ApiService.syncReports(reportSyncData);

          // Mark successfully synced reports
          if (reportResult.synced.length > 0) {
            await Promise.all(reportResult.synced.map((id) => updateReportStatus(id, 'synced')));
          }

          // Log any sync errors (but don't fail the entire sync)
          if (reportResult.errors.length > 0) {
            console.warn('Report sync errors:', reportResult.errors);
          }
        }

        // Sync alerts
        if (pendingAlerts.length > 0) {
          const alertSyncData = pendingAlerts.map((alert) => ({
            id: alert.id,
            phoneNumber: alert.phoneNumber,
            createdAt: alert.createdAt,
          }));

          const alertResult = await ApiService.syncAlerts(alertSyncData);

          // Log sync results (alerts stay local regardless)
          if (alertResult.errors.length > 0) {
            console.warn('Alert sync errors:', alertResult.errors);
          }
        }

        // Try to fetch updated resources
        const resourceResult = await ApiService.fetchResources();
        if (resourceResult.resources) {
          // In a real implementation, you might want to merge/update local resources
          // For now, we just log that resources are available
          console.log(`Fetched ${resourceResult.resources.length} resources from server`);
        } else if (resourceResult.error) {
          console.warn('Failed to fetch resources:', resourceResult.error);
        }

        // Refresh local data
        await refreshReports();
        await refreshAlerts();

        setState((prev) => ({ ...prev, syncState: 'idle' }));

      } catch (error) {
        console.error('Sync failed:', error);
        setState((prev) => ({ ...prev, syncState: 'error' }));
      }
    },
    completeOnboarding: async () => {
      await AsyncStorage.setItem(STORAGE_KEYS.onboarding, 'true');
      setState((prev) => ({ ...prev, hasCompletedOnboarding: true }));
    },
    togglePinLock: async () => {
      const next = !state.pinEnabled;
      await AsyncStorage.setItem(STORAGE_KEYS.pinEnabled, next ? 'true' : 'false');
      setState((prev) => ({ ...prev, pinEnabled: next }));
    },
    toggleBiometric: async () => {
      if (!state.biometricEnabled) {
        const hardware = await LocalAuthentication.hasHardwareAsync();
        if (!hardware) {
          Alert.alert('Biometric unavailable', 'Your device does not support biometric authentication.');
          return;
        }
        const enrolled = await LocalAuthentication.isEnrolledAsync();
        if (!enrolled) {
          Alert.alert('Biometric unavailable', 'Please enroll a fingerprint or face ID first.');
          return;
        }
        const result = await LocalAuthentication.authenticateAsync({
          promptMessage: 'Enable biometric lock',
          cancelLabel: 'Cancel',
        });
        if (!result.success) {
          return;
        }
      }
      const next = !state.biometricEnabled;
      await AsyncStorage.setItem(STORAGE_KEYS.biometricEnabled, next ? 'true' : 'false');
      setState((prev) => ({ ...prev, biometricEnabled: next }));
    },
    loadReportForEdit: async (id: number) => {
      const report = await getReportById(id);
      return report;
    },
    signIn: async () => {
      await AsyncStorage.setItem(STORAGE_KEYS.authenticated, 'true');
      setState((prev) => ({ ...prev, isAuthenticated: true }));
    },
  };

  const value = useMemo<AppContextValue>(
    () => ({
      ...state,
      actions,
    }),
    [state],
  );

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

export function useAppContext() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
}

